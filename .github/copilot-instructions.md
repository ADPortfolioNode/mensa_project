## Mensa Project – AI Agent Guide
- **Goal**: Lottery data ingestion + simple model training/prediction + chat UI. Backend is FastAPI ([backend/main.py](backend/main.py)); frontend is React ([frontend/src/App.js](frontend/src/App.js)); vector store is ChromaDB ([backend/services/chroma_client.py](backend/services/chroma_client.py)).
- **Containers**: `docker compose up --build` (see [compose.yaml](compose.yaml)). Backend mounts `./data` at `/data`, expects Gemini key (`GEMINI_API_KEY`); frontend needs `.env` with `REACT_APP_API_BASE`. Chroma runs on 8000. Backend currently listens on 8000 inside the container but compose maps 5000:5000—align port/env before shipping.
- **Configs**: [backend/config.py](backend/config.py) holds `GAME_CONFIGS`, dataset endpoints, and Chroma host/port. Extend here when adding games or data sources.
- **Startup flow**: First call to `/api/startup_status` triggers background ingestion across all games. Progress is tracked in `startup_state` in [backend/main.py](backend/main.py) and pushed via the same endpoint; frontend [StartupProgress](frontend/src/components/StartupProgress.js) polls it every 2s.
- **Ingestion**: [backend/services/ingest.py](backend/services/ingest.py) pulls Socrata JSON, batches 500 rows, writes to Chroma collections named by game. Retries with backoff; optional `progress_callback` updates UI. If adding schemas, keep `metadatas` aligned and stable IDs (currently md5 of row).
- **Training**: [backend/services/trainer.py](backend/services/trainer.py) is placeholder RF on `winning_numbers` string; models saved to `/data/models/{game}_model.joblib`. Feature engineering must populate `winning_numbers` in Chroma metadata.
- **Prediction**: [backend/services/predictor.py](backend/services/predictor.py) loads joblib, pulls recent docs from Chroma, splits `winning_numbers`, predicts, and returns list. Add validation around Chroma ordering and metadata presence before expanding.
- **Experiments storage**: [backend/experiments/store.py](backend/experiments/store.py) writes JSON list to `/data/experiments/experiments.json`. Keep writes atomic if you add concurrency.
- **Chat**: [backend/services/gemini_client.py](backend/services/gemini_client.py) wraps Gemini; raises on missing key. `/api/chat` simply forwards prompt and returns text. Frontend [ChatPanel](frontend/src/components/ChatPanel.js) renders markdown via `marked`.
- **Frontend patterns**: API base normalized in [Dashboard](frontend/src/components/Dashboard.js) and [ChromaStatusPanel](frontend/src/components/ChromaStatusPanel.js); prefer passing a fully qualified `REACT_APP_API_BASE` (http/https). Dashboard drives ingest/train buttons; experiments are polled every 5s; predictions require a trained model.
- **Error handling (existing)**: Frontend startup uses `analyzeError` in [frontend/src/utils/errorUtils.js](frontend/src/utils/errorUtils.js) to classify connection issues and show [ErrorMessage](frontend/src/components/ErrorMessage.js). Backend prints and returns simple status dicts; no global exception middleware yet.
- **Error handling (proposed single-point observer)**: Add a small event-bus at `frontend/src/utils/errorBus.js` that exposes `publish(errorContext)` and `subscribe(listener)`; wire axios/fetch interceptors and component catches to publish; render a top-level toast/banner subscriber in `App`. Backend: add FastAPI middleware to log/normalize exceptions to a structured shape `{path, detail, category, correlation_id}` and optionally emit to a central logger; keep all services raising domain errors so middleware is the single translation point. This keeps future builds reusing the same observer pattern without scattering try/catch.
- **Data contracts**: Chroma metadata must include `winning_numbers` string; experiments endpoint expects `experiments` array; `startup_status` returns per-game map `{status, error}`. Preserve shapes when extending to avoid frontend breakage.
- **Ports & envs**: Chroma host/port come from env via `settings`; frontend default assumes `http://backend:5000`. Align backend `uvicorn` port and compose mapping before releases.
- **File naming**: Collections are per-game; model artifacts mirror game names. Keep names consistent across ingest/train/predict.
- **Security**: Backend CORS is wide open (`allow_origins=['*']`); tighten for production. Gemini key must be provided or backend will raise at startup.
- **Common commands**: `docker compose up --build`; `npm start` in frontend for local dev; `python main.py` in backend (but prefer `uvicorn main:app --reload --host 0.0.0.0 --port 8000`).

Ask the user if any section is unclear or missing so we can refine this guide.